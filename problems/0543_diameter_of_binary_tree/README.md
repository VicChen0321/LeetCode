# 543. Diameter of Binary Tree

**LeetCode Link:** [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)
**Difficulty:** Easy
**Tags:** Tree, Depth-First Search, Binary Tree

---

## 題目描述

給定一棵二元樹的根節點 `root`，請計算該樹的 **直徑 (Diameter)**。

* **直徑的定義**：樹中任意兩個節點之間的最長路徑長度。
* 這條路徑 **不一定** 會經過根節點。
* 兩節點間的路徑長度是以它們之間 **邊 (edges)** 的數量來表示，而不是節點數。

### 範例

* **Input:** `root = [1,2,3,4,5]` → **Output:** `3`
**解釋：** 最長路徑是 `[4,2,1,3]` 或 `[5,2,1,3]`，其長度（邊的數量）為 3。
* **Input:** `root = [1,2]` → **Output:** `1`

---

## 解法概念

計算直徑的核心直覺是：任意一個節點作為「轉折點」時，通過該節點的最長路徑就是 **左子樹的高度 + 右子樹的高度**。

### 方法：深度優先搜索 (DFS) / 遞迴

1. **定義遞迴函數的作用**：
我們需要一個 DFS 函數，它回傳的是該節點的 **高度 (Height)**。高度定義為從該節點到最遠葉子節點的邊數。
2. **更新直徑 (Global State)**：
在遞迴計算高度的過程中，我們同時計算通過當前節點的「局部直徑」：
`current_diameter = left_height + right_height`
並用一個全域變數 `max_diameter` 來持續追蹤並更新最大值。
3. **高度的回傳邏輯**：
當前節點回傳給父節點的高度應為：
`max(left_height, right_height) + 1`
4. **關鍵 Insight**：
本題使用了 **「一箭雙鵰」** 的技巧：遞迴的 **回傳值** 用於提供父節點計算高度，而遞迴的 **過程** 則用於更新全域的直徑最大值。

> **小提示：**
> 如果題目定義長度為「節點數」，公式會是 `left_height + right_height + 1`。但本題定義為「邊數」，所以直接相加高度即可。

---

## 時間與空間複雜度

* **時間複雜度**：$O(N)$
每個節點恰好被訪問一次。
* **空間複雜度**：$O(H)$
其中 $H$ 是樹的高度。在最壞情況下（斜長樹），遞迴棧深度為 $O(N)$；在平衡樹中則為 $O(\log N)$。

---

## 常見錯誤陷阱

1. **誤以為直徑一定經過根節點**：這是新手最常犯的錯誤。如果樹的左子樹非常龐大且深，最長路徑可能完全隱藏在左子樹中。
2. **邊數與節點數混淆**：
    * 邊數 (Edges) = 節點數 - 1。
    * 遞迴回傳時 `+1` 的邏輯要與空節點回傳 `0` 的定義一致。
