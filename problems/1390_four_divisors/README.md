# 1390. Four Divisors

**LeetCode Link:** [https://leetcode.com/problems/four-divisors/](https://leetcode.com/problems/four-divisors/)

**Difficulty:** Medium

**Tags:** Math, Array

---

## 題目描述

給定一個整數陣列 `nums`，請計算該陣列中所有「**恰好擁有 4 個因數**」的整數，其因數的總和。

如果一個整數的因數個數不是 4 個，則忽略該整數。最後回傳所有符合條件整數的因數總和。

* **因數 (Divisor)**：若整數 `a` 能被整數 `b` 整除，則 `b` 是 `a` 的因數。
* **限制**：
* `1 <= nums.length <= 10^4`
* `1 <= nums[i] <= 10^5` (數字範圍不大，暗示可以用 $\sqrt{N}$ 複雜度解)



### 範例

**Example 1**

* Input: `nums = [21, 4, 7]`
* Output: `32`
* 解釋：
* **21** 的因數有：1, 3, 7, 21。共有 4 個，符合條件。因數和 = 。
* **4** 的因數有：1, 2, 4。共有 3 個，不符合條件。
* **7** 的因數有：1, 7。共有 2 個，不符合條件。
* 結果：只計算 21 的因數和，故回傳 32。



**Example 2**

* Input: `nums = [21, 21]`
* Output: `64`
* 解釋：兩個 21 都符合條件，。

---

## 解法概念

這題的核心在於如何**快速求出一個數的因數個數與總和**。由於數字範圍最大到 $10^5$，對每個數字跑 $O(N)$ 暴力找因數會太慢，必須利用數學性質優化。

### 方法：試除法 (Trial Division) 至平方根

1. **遍歷陣列**：
對 `nums` 中的每一個數字 `n` 進行檢查。
2. **尋找因數**：
不需要從 1 遍歷到 `n`，只需要遍歷從 $1$ 到 $\lfloor\sqrt{n}\rfloor$ 即可。
* 如果 `i` 能整除 `n` (`n % i == 0`)，則 `i` 是一個因數。
* 同時，`n / i` 也是另一個對應的因數。


3. **計算個數與總和**：
* 若 `i * i == n` (完全平方數)：只找到 1 個因數 (`i`)。
* 若 `i * i != n`：找到 2 個因數 (`i` 和 `n/i`)。
* 將找到的因數加到目前的 `sum`，並增加 `count`。


4. **剪枝 (Pruning)**：
* 在尋找過程中，如果 `count > 4`，代表這個數字已經不符合要求，直接 `break` 放棄，節省時間。


5. **結算**：
* 迴圈結束後，只有當 `count == 4` 時，才將該數字的因數和加入最終結果 `totalSum`。



> **關鍵 Insight**：
> 什麼樣的數字會有恰好 4 個因數？
> 1. 兩個不同質數的乘積 (例如 $6 = 2 \times 3$，因數為 1, 2, 3, 6)。
> 2. 一個質數的立方 (例如 $8 = 2^3$，因數為 1, 2, 4, 8)。
> 不過這題不需要判斷質數，直接用 $\sqrt{n}$ 法找因數最直觀且效率足夠。
> 
> 

---

## 時間與空間複雜度

令 $N$ 為陣列長度 (nums.length)，$M$ 為陣列中數字的最大值 (10^5)。
* **時間複雜度：** $O(N \cdot \sqrt{M})$對陣列中每個數字，我們都需要遍歷到它的平方根。$\sqrt{100000} \approx 316$，這是一個很小的常數，整體運算量約 $10^4 \times 316 \approx 3 \times 10^6$，遠低於一般 Time Limit ($10^8$)。
* **空間複雜度：** $O(1)$不需要額外的陣列或資料結構，僅需常數變數儲存總和與計數。

---

### 常見錯誤陷阱

1. **完全平方數處理**：容易忘記當 `i * i == n` 時，因數只有一個，如果不小心加了兩次 (加了 `i` 和 `n/i`) 會導致計數與總和錯誤。
2. **邊界條件**：若 `num` 很小（例如 1），迴圈與邏輯需能正確處理（1 只有 1 個因數）。
3. **剪枝判斷**：雖然不加 `if (count > 4) break` 也能通過，但加上去能顯著提升執行效率，特別是當數字很大且因數很多時。
