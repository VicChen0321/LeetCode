# 1161. Maximum Level Sum of a Binary Tree

**LeetCode Link:** [1161. Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)

**Difficulty:** Medium

**Tags:** Binary Tree, Breadth-First Search (BFS), Depth-First Search (DFS)

---

## 題目描述

給定一個二元樹的根節點 `root`，請找出其節點值總和 **最大** 的那一層（Level）。

* 層級編號從 **1** 開始（根節點為第 1 層，其子節點為第 2 層，依此類推）。
* 如果有多個層級的總和相同且皆為最大值，則回傳 **層級編號最小** 的那一層。

### 範例

* **Input:** `root = [1,7,0,7,-8,null,null]` → **Output:** `2`
**解釋：**
* 第 1 層：總和 = 1
* 第 2 層：總和 = 7 + 0 = 7
* 第 3 層：總和 = 7 + (-8) = -1
最大總和出現在第 2 層。

* **Input:** `root = [989,null,10250,98693,-86888,null,null,null,-147]` → **Output:** `2`

---

## 解法概念

這是一道典型的 **層序遍歷（Level Order Traversal）** 題目。我們需要「一層一層」地計算總和，並在遍歷過程中不斷更新最大值。

### 方法：廣度優先搜索 (BFS)

1. **初始化隊列 (Queue)**：
使用一個隊列來存放節點，初始時將 `root` 加入隊列。
2. **層級迭代**：
當隊列不為空時，代表還有下一層需要處理。在進入每一層的循環前，先記錄當前隊列的長度 `size`，這代表 **這一層共有多少個節點**。
3. **計算當層總和**：
取出這 `size` 個節點，將它們的值累加至 `levelSum`，並將它們各自的左、右子節點放入隊列中供下一層使用。
4. **更新全局最大值**：
比較 `levelSum` 與目前記錄的 `maxSum`：

* 如果 `levelSum > maxSum`，則更新 `maxSum` 為 `levelSum`，並記錄當前層號 `maxLevel = currentLevel`。
* **關鍵 Insight**：由於我們是從小到大遍歷層級，若遇到相同的總和，我們不需要更新 `maxLevel`，這樣就能自然地保留「最小層級編號」。

1. **回傳結果**：
遍歷結束後，回傳 `maxLevel`。

> **小提示：** > 初始 `maxSum` 應設定為一個極小值（例如 Python 的 `float('-inf')` 或 Java 的 `Integer.MIN_VALUE`），因為節點的值可能是負數，某一層的總和完全有可能是負的。

---

## 時間與空間複雜度

* **時間複雜度**：$O(N)$ 我們必須訪問樹中的每個節點恰好一次，其中 $N$ 是節點的總數。
* **空間複雜度**：$O(W)$ $W$ 是樹的最大寬度。在最壞情況下（完全二元樹），隊列中最多會存放 $N/2$ 個節點。

---

## BFS 與 DFS 方法比較

|特性|BFS (層序遍歷)|DFS (深度遍歷)|
|-------|------------|-------------|
|直觀程度|極高，天然符合「按層」邏輯|需額外紀錄層號與儲存空間|
|額外空間|$O(W)$，取決於樹的最大寬度|$O(H)$，取決於樹的高度|
|適用場景|樹很寬但很淺時|樹很窄但很深時|
|實作關鍵|使用 Queue|使用 Recursion + List/Map|

---

## 常見錯誤陷阱

1. **初始值設為 0**：如果樹的所有層級總和都是負數（例如所有節點都是 -10），若將 `maxSum` 設為 0，最終結果會出錯。
2. **層級從 0 開始**：題目明確要求層級從 1 開始，計數時要小心。
3. **更新條件寫成 `>=**`：題目要求若總和相同，回傳最小的層級。如果使用 `>=`，你會回傳最後一個（最大的）相同總和的層級。
