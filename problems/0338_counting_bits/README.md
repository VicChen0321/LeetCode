# 338 Counting Bits

**LeetCode Link:**
[338. Counting Bits](https://leetcode.com/problems/counting-bits/)

**Difficulty:** Easy
**Tags:** Dynamic Programming, Bit Manipulation

---

## 題目描述

給定一個整数 `n`，返回一個長度為 `n+1` 的陣列 `ans`，其中 `ans[i]` 表示 **i 的二進位表示中 1 的個數**。

---

### 範例

**Input**

```
n = 2
```

**Output**

```
[0,1,1]
```

**解釋**

* 0 → 0
* 1 → 1
* 2 → 10 → 1 個 1

---

**Input**

```
n = 5
```

**Output**

```
[0,1,1,2,1,2]
```

**解釋**

* 0 → 0
* 1 → 1
* 2 → 10 → 1
* 3 → 11 → 2
* 4 → 100 → 1
* 5 → 101 → 2

---

## 解法概念

### 方法：DP + 位運算

使用以下公式：

```
dp[i] = dp[i >> 1] + (i & 1)
```

解釋：

* `i >> 1` 相當於把 `i` 除以 2，去掉最後一位
* `i & 1` 用來判斷 `i` 是否為奇數（最後一位是否為 1）

例：
`i = 5 (101)`
→ `i >> 1 = 2 (10)`
→ `i & 1 = 1`
→ `dp[5] = dp[2] + 1`

## 時間與空間複雜度

| 項目        | 複雜度  |
| --------- | ---- |
| **時間複雜度** | O(n) |
| **空間複雜度** | O(n) |

---

## 核心關鍵

* 利用 **i >> 1 減少計算量**
* 使用 `(i & 1)` 判斷最後一位是否為 1
* DP 避免重複計算

---

## 優化版本

可使用以下進階公式（若有學到 bit DP）：

```
dp[i] = dp[i & (i - 1)] + 1
```

（將 i 的最右邊 1 去掉）

但上面的 `(i >> 1) + (i & 1)` 更易懂，也常用於面試。
