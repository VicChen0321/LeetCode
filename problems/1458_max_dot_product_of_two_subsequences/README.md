# 1458. Max Dot Product of Two Subsequences

**LeetCode Link:** [1458. Max Dot Product of Two Subsequences](https://leetcode.com/problems/max-dot-product-of-two-subsequences/)

**Difficulty:** Hard

**Tags:** Array, Dynamic Programming

---

## 題目描述

給定兩個陣列 `nums1` 和 `nums2`，請從這兩個陣列中分別選出兩個**長度相同**且**非空**的子序列，使得它們的**內積（Dot Product）最大**。

* **子序列**：指從原陣列中刪除零個或多個元素後，剩餘元素保持原相對順序組成的序列。
* **內積**：若選出的子序列為 $[a_1, a_2, \dots, a_k]$ 和 $[b_1, b_2, \dots, b_k]$，則內積為 $\sum_{i=1}^{k} a_i \times b_i$
* **限制**：子序列必須非空（至少要選一個數對）。

### 範例

* **Input:** `nums1 = [2,1,-2,5], nums2 = [3,0,-6]` → **Output:** `18`
**解釋：** 從 `nums1` 選出 `[2,-2]`，從 `nums2` 選出 `[3,-6]`，內積為 。
* **Input:** `nums1 = [-1,-1], nums2 = [1,1]` → **Output:** `-1`
**解釋：** 即使所有乘積都是負的，仍必須選出一對，最大值為 。

---

## 解法概念

這題可以用動態規劃來解決。我們需要決定對於 `nums1[i]` 和 `nums2[j]`，是否將它們配對並加入當前的內積中。

### 方法：Dynamic Programming (2D DP)

1. **定義 DP 狀態**：
定義 $dp[i][j]$ 為從 `nums1` 的前 $i$ 個元素和 `nums2` 的前 $j$ 個元素中能獲得的最大內積。
2. **轉移方程式**：
對於每一對 $(i, j)$，當前最大內積有四種來源：

* **只選當前這一對**：`nums1[i] * nums2[j]`。
* **選當前這一對並加上之前的最優解**：`nums1[i] * nums2[j] + dp[i-1][j-1]`（僅當 $dp[i-1][j-1] > 0$ 時有效）。
* **不選 nums1[i]**：繼承 `dp[i-1][j]`。
* **不選 nums2[j]**：繼承 `dp[i][j-1]`。

綜合公式：$dp[i][j] = \max(nums1[i] \times nums2[j] + \max(0, dp[i-1][j-1]), dp[i-1][j], dp[i][j-1])$

1. **邊界條件與初始化**：
由於可能出現全負數的情況，初始化時應設為極小值。為了簡化 $i-1$ 或 $j-1$ 的邊界判斷，可以多開一列一行，或在循環內處理。
2. **關鍵 Insight**：
這題與 LCS (Longest Common Subsequence) 的差別在於，當前的 $nums1[i] \times nums2[j]$ 如果是負的，我們可能會選擇放棄累加之前的結果，轉而重新開始一個子序列對。

> **小提示：**
> 如果 `nums1[i] * nums2[j]` 加上 `dp[i-1][j-1]` 反而變小，代表之前的子序列和是負貢獻，此時我們「斷捨離」，只取 `nums1[i] * nums2[j]`。

---

## 時間與空間複雜度

* **時間複雜度**：$O(M \times N)$
其中 $M, N$ 分別為兩個陣列的長度。我們需要填滿一個二維矩陣。
* **空間複雜度**：$O(M \times N)$
可以使用二維陣列。若使用滾動陣列優化，空間可降至 $O(N)$。

---

## 常見錯誤陷阱

1. **全負數處理**：如果 `nums1 = [-1]` 且 `nums2 = [1]`，答案應該是 `-1`。初始化時如果給 0，會導致輸出錯誤的 0（因為題目要求非空）。
2. **子序列順序**：子序列不能打亂原有的相對順序，因此必須使用 DP 來維護前綴的最優狀態。
3. **內積長度**：雖然題目說長度相同，但 DP 的轉移過程自然地保證了我們是「成對」選取的，不需要額外紀錄長度。
