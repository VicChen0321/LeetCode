# 37 Sudoku Solver

**LeetCode Link:** [37. Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)  
**Difficulty:** Hard  
**Tags:** Backtracking, Matrix, Hash Table

---

## 題目描述
給定一個 `9x9` 的數獨盤面，空格用 `'.'` 表示。請填滿整個盤面，使得每行、每列、每個 `3x3` 小格中的數字 `1–9` 各出現一次。

---

## 解法概念

**方法：DFS 再搭配 Backtracking**

**核心思路：**
- 使用遞迴 + 回溯架構，依序填補空格。
- 同時維護三個狀態：
  - `rows[i][d]`: 數字 `d+1` 是否已出現在第 i 行？
  - `cols[j][d]`: 數字 `d+1` 是否已出現在第 j 列？
  - `blocks[i//3][j//3][d]`: 數字 `d+1` 是否已出現在第 (i, j) 所屬的 3x3 格中？

**演算法流程：**
1. 初始化 `rows`、`cols`、`blocks` 的布林陣列。
2. 掃描整個盤面，填入已知數字，並更新三個矩陣的狀態。
3. 收集所有空格位置到 `empty_cells` 列表。
4. 遞迴函數 `dfs(k)`：
   - 若 `k == len(empty_cells)`，代表已填滿所有格子，完成解答。
   - 否則，對第 k 個空格嘗試數字 `1–9`：
     - 若在 row、col、block 中都沒出現過，即合法，將其填入並更新狀態。
     - 遞迴進入 `dfs(k+1)`。若成功，立即終止；否則回溯（復原狀態）。
5. 回溯完成後，盤面即被原地修改至最終解。

---

## 時間與空間複雜度
- **時間複雜度：** 最差情況為指數級，O(9^m)，m 是空格數量（每個空格猜 1–9）；但因盤面大小固定為 `9x9`，實際可認為是 O(1)。
- **空間複雜度：** 使用固定大小的布林陣列 + 建立在 stack 上的遞迴，總體可視為 O(1)（固定盤面尺寸）。

---

## 核心關鍵
- **回溯設計**：能深度解與回溯所有可能組合
- **狀態剪枝**：立刻檢查 row/col/block 限制，減少無效遞迴
- **位置預先收集**：只對空白格進行填寫，避免重複掃描

---

## 延伸方向
- 探索更高效率的 Bitmask 結合回溯方法（用 bit 來標記 row/col/block 狀態）
- 若盤面尺寸改變（如 `16x16`），需動態調整狀態儲存與限制條件