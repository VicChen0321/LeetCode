這是一份為你準備的 LeetCode 1339 題目的完整筆記，這題非常經典，能幫助你深入理解二元樹的子樹和（Subtree Sum）概念。

---

# 1339. Maximum Product of Splitted Binary Tree

**LeetCode Link:** [1339. Maximum Product of Splitted Binary Tree](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/)

**Difficulty:** Medium

**Tags:** Tree, Depth-First Search (DFS), Binary Tree

---

## 題目描述

給定一棵二元樹的根節點 `root`，你可以**刪除其中任意一條邊**，將這棵樹分裂成兩棵獨立的子樹。

* 你的目標是找到一種刪除方式，使得這兩棵子樹的**節點值總和相乘後乘積最大**。
* 由於答案可能非常大，請將結果對 $10^9+7$ 取模（Modulo）。
* **注意**：你需要先計算出最大乘積，**最後**再取模，而不是在計算過程中取模。

### 範例

* **Input:** `root = [1,2,3,4,5,6]` → **Output:** `110`
**解釋：**
* 整棵樹的總和為 21。
* 若刪除連接節點 2 和 節點 1 的邊，兩棵子樹和分別為 11 (2+4+5) 與 10 (1+3+6)，乘積 $11 \times 10 = 110$ 。這是最大可能值。

* **Input:** `root = [1,null,2,3,4,null,null,5,6]` → **Output:** `90`

---

## 解法概念

這題的核心直覺是：當你刪除一條邊，斷開的那個節點所帶領的**子樹和**（設為 $S_{sub}$）會成為其中一個乘數，而剩下的部分（全樹總和減去子樹和，$S_{total} - S_{sub}$）則是另一個乘數。

### 方法：兩次 DFS 遍歷

1. **第一次 DFS：計算全樹總和 ($S_{total}$)**
遍歷整棵樹，計算所有節點值的總和。這將作為我們計算「剩餘部分」的基準。
2. **第二次 DFS：計算所有可能的子樹和並更新最大乘積**
遍歷每個節點，計算以該節點為根的子樹總和 $S_{sub}$。

* 每得到一個 $S_{sub}$，我們就可以模擬「剪斷」它與父節點之間的邊。
* 計算乘積：$P = S_{sub} \times (S_{total} - S_{sub})$。
* 維護一個全域變數 `max_product` 來記錄最大值。

1. **數學原理**：
根據算幾不等式，當兩個數的和固定時（即 $S_{total}$），兩個數越接近，其乘積越大。因此，我們的目標是找到一個 ，使其儘可能接近 $S_{total} / 2$。

> **小提示：** 為了優化，你可以在第一次 DFS 的過程中，將所有計算出的子樹和存在一個 List 或 Set 中，這樣就不需要第二次遞迴，直接遍歷 List 即可。

---

## 時間與空間複雜度

* **時間複雜度**：$O(N)$
我們需要遍歷樹中的每個節點來計算總和（ 為節點數）。
* **空間複雜度**：$O(H+N)$ 或 $O(N)$
  * $O(H)$ 是遞迴造成的棧空間（ 為樹高）。
  * 如果我們選擇存下所有子樹和，則需要額外的 $O(N)$ 空間。

---

## 常見錯誤陷阱

1. **過早取模**：這題最常見的錯誤是在計算 `product` 時就取模。如果 $A > B$，但 $A \pmod M$ 可能小於  $B \pmod M$ 。正確做法是找出真正的最大乘積後，最後再取一次模。
2. **整數溢位**：在 Java 或 C++ 中，`product` 可能會超過 32 位整數（`int`）的範圍，必須使用 `long` 來存儲中間結果。
3. **忽略根節點**：根節點的子樹和等於 `total_sum`，雖然  $total\_sum \times (total\_sum - total\_sum) = 0$  不會影響最大值，但邏輯上要清楚我們是在「切斷邊」。
