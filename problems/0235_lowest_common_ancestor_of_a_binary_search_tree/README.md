# 235. Lowest Common Ancestor of a Binary Search Tree

**LeetCode Link:** [235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

**Difficulty:** Medium

**Tags:** Tree, Binary Search Tree, Depth-First Search, Binary Tree

---

## 題目描述

給定一個 **二元搜尋樹 (BST)** 以及其中兩個節點 `p` 和 `q`，請找出它們的 **最近共同祖先 (Lowest Common Ancestor, LCA)**。

* **LCA 的定義**：對於有根樹中的兩個節點 `p`、`q`，最近共同祖先 `x` 滿足：`x` 是 `p` 和 `q` 的祖先，且 `x` 的深度盡可能大（即位置越低越好）。
* 一個節點也可以是其自身的祖先。

### 範例

* **Input:** `root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8` → **Output:** `6`
解釋：節點 2 和 8 的最近共同祖先是 6。
* **Input:** `root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4` → **Output:** `2`
解釋：節點 2 是節點 4 的祖先，根據定義，LCA 為 2。

---

## 解法概念

這題的核心在於利用 **二元搜尋樹 (BST)** 的特性：對於任何節點 `node`，其左子樹的所有節點值都小於 `node.val`，右子樹的所有節點值都大於 `node.val`。

### 方法：利用 BST 特性的迭代/遞迴遍歷

1. **比較數值大小**：
從根節點 `root` 開始遍歷。
2. **判斷方向**：

* 如果 `p` 和 `q` 的值都 **小於** 當前節點的值：說明 `p` 和 `q` 都在當前節點的 **左子樹**，我們應往左走 (`root = root.left`)。
* 如果 `p` 和 `q` 的值都 **大於** 當前節點的值：說明 `p` 和 `q` 都在當前節點的 **右子樹**，我們應往右走 (`root = root.right`)。

1. **找到分叉點**：

* 當上述兩個條件都不滿足時（即一個較大、一個較小，或者其中一個等於當前節點值），當前節點就是它們的 **最近共同祖先 (LCA)**。

1. **關鍵 Insight**：
在 BST 中，LCA 必然是第一個數值位在 `[min(p, q), max(p, q)]` 區間內的節點。

> **小提示：** > 不需要考慮 `p` 或 `q` 不在樹中的情況（題目通常保證存在）。此外，因為是 BST，我們不需要像普通二元樹那樣遍歷整棵樹。

---

## 時間與空間複雜度

* **時間複雜度**：$O(H)$
其中 $H$ 是樹的高度。在最壞情況下（斜長樹），我們可能需要從根走到葉子節點。
* **空間複雜度**：$O(1)$
如果使用迭代法（Iteration），只需要常數空間。如果使用遞迴，則為 $O(H)$ 的系統棧空間。

---

## 常見錯誤陷阱

1. **忘記利用 BST 特性**：很多人會直接用第 236 題（普通二元樹 LCA）的解法來做，雖然結果正確，但時間效率在某些情況下會較慢，且面試官通常期待你展現對 BST 特性的掌握。
2. **過度複雜的判斷**：不需要判斷 `p` 是否在左、`q` 是否在右，只需要確認它們是否「都在同一邊」即可。
3. **空指標檢查**：在題目給定的約束下（`p`, `q` 必存在於樹中），雖然 `while root` 足夠，但實作時養成檢查習慣會更魯棒。
