# 236. Lowest Common Ancestor of a Binary Tree

**LeetCode Link:** [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

**Difficulty:** Medium

**Tags:** Tree, Depth-First Search, Binary Tree

---

## 題目描述

給定一個 **二元樹**（不保證是 BST）以及其中兩個節點 `p` 和 `q`，請找出它們的 **最近共同祖先 (LCA)**。

* **條件限制**：
* 所有節點的值都是唯一的。
* `p` 和 `q` 均存在於給定的二元樹中。
* 節點也可以是其本身的祖先。

### 範例

* **Input:** `root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1` → **Output:** `3`
* **Input:** `root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4` → **Output:** `5`
（因為節點 5 是節點 4 的祖先，所以 LCA 是 5）

---

## 解法概念

由於沒有了數值大小的引導，我們必須使用 **後序遍歷 (Post-order Traversal)** 的概念：由下而上回傳資訊。

### 方法：遞迴後序遍歷 (DFS)

1. **遞迴終止條件**：

* 如果當前節點 `root` 為空，回傳 `null`。
* 如果當前節點 `root` 就是 `p` 或 `q`，直接回傳 `root`（表示找到了目標之一）。

1. **向下搜索**：

* 遞迴搜索左子樹，結果存為 `left`。
* 遞迴搜索右子樹，結果存為 `right`。

1. **判斷與回傳 (核心邏輯)**：

* **情況 A**：`left` 和 `right` 都不為空。
這代表 `p` 和 `q` 分別分布在當前節點的左、右子樹，因此 **當前節點 `root` 就是 LCA**。
* **情況 B**：`left` 為空，但 `right` 不為空。
代表這兩點都在右子樹中，或者右子樹找到了其中一個點，回傳 `right`。
* **情況 C**：`right` 為空，但 `left` 不為空。
回傳 `left`。
* **情況 D**：都為空。
回傳 `null`。

> **關鍵 Insight：**
> 這種解法本質上是在問：「在我的子樹裡，有沒有看到 `p` 或 `q`？」
> 如果左右兩邊都有看到，那我就是那個分叉點（LCA）。

---

## 時間與空間複雜度

* **時間複雜度**：$O(N)$
其中 $N$ 是節點總數。在最壞情況下，我們需要走過所有節點。
* **空間複雜度**：$O(H)$
其中 $H$ 是樹的高度。遞迴棧的深度取決於樹高，最壞情況為 $O(N)$。

---

## 常見錯誤陷阱誤

1. 用 BST 邏輯：在普通二元樹中，節點值的大小與其在樹中的位置無關，不能用 `val` 比較。
2. 忘記處理 `root == p` 或 `q` 的情況：如果其中一個節點是另一個的祖先，遞迴會在遇到較高層的那個點時就直接回傳。
3. 過度思考：有些人會想紀錄從根到 `p` 和 `q` 的路徑，這雖然也是一種解法（$O(N)$ 空間），但比上述遞迴法實作起來更複雜。
